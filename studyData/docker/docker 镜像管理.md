## 镜像管理
[原地址](https://cloud.tencent.com/developer/article/1541520)

#### 什么是docker镜像
docker镜像是一个只读的docker容器模版，含有启动docker容器所需的文件系统结构及其内容，因此是启动一个docker容器的基础。docker镜像的文件内容以及一些运行docker容器的配置文件组成了docker容器的静态文件系统运行环境（`rootfs`）.可以理解为，docker镜像是docker容器的静态视角，docker容器是docker像的运行状态。

1. rootfs

	rootfs是docker容器在启动时内部进程可见的文件系统，即docker容器的根目录，rootfs通常包含一个操作系统运行所需的文件系统，例如：可能包含典型的类unix操作系统中的目录系统，如/dev,/proc,/bin,/etc,/lib,/user,/tmp以及运行的docker容器所需的配置文件、工具等。

	在docker架构中，当docker daemon 为docker容器挂载rootfs时，沿用了linux内核启用时的方法，即将rootfs设为只读模式。在挂载之后，利用联合挂载（union mount）技术在已有的只读rootfs上再挂载一个读写层，这样，可读写层处于docker容器的文件系统最顶层，其下可能联合挂载多个只读层，只有在docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到读写层，并隐藏只读层中的老版本文件。

2. docker镜像的主要特点
	
	- 分层
	
		docker镜像是采用分层的方式构建的，每个镜像都是由一系列的`镜像层`组成。分层结构是docker镜像如此轻易的重要的原因，当需要修改容器镜像内的某个文件时，只对处于最上层的读写层进行改变，不覆盖下层只读层的文件系统内容，已有文件在只读层的原始版本依然存在，但会被读写层的新版文件所隐藏。当使用docker commit提交时这个修改过的容器文件系统为一个新的镜像时，保存的内容仅为最上层读写层文件系统中被更新过的文件，分层达到了不同镜像之间的共享镜像层的效果。

	- 写时复制
	
		docker镜像使用了写时复制（copy-on-write）策略，在多个容器之间共享镜像，每个容器在启动的时候并不需要单独复制一份镜像文件，而是将所有镜像层以只读的方式挂载到一个挂载点上，再在上面覆盖一个可读写的容器层。在未更改文件内容时，所有容器共享同一份数据，只有在docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层中，并隐藏只读层的老版文件。写时复制配合分层机制减少了镜像对磁盘空间的占用和容器的启用时间。

	- 内容寻址

		内容寻址储存( content-addressable storage）的机制，根据文件内容来索引镜像和镜像层，docker对镜像层的内容计算校验和生成一个内容哈希值，并以此哈希值代替之前的UUID作为镜像层的唯一标志，该机制主要提高了镜像的安全性，并在pull,push,load和save操作后检测数据的完整性。另外，基于内容哈希来索引镜像层，在一定程度上减少了ID的冲突并加强了镜像层的共享。对于来自不同构建的镜像层，只要拥有相同的内容哈希，也能被不同的镜像共享。

	- 联合挂载
	
		通俗的讲，联合挂载技术可以在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载的内容进行整合，使得最终可见的文件系统将包含整合之后的各层的文件和目录。实现这种联合挂载技术的文件系统通常被称为联合文件系统
（union filesystem）。
	
		![文件系统示意图](./images/文件系统示意图.png)

#### docker镜像关键概念
1. registry
	
	registry用以保存docker镜像，其中包括镜像层次结构和关于镜像的元数据。可以将registry简单的想象成git仓库之类的实体

2. repository

	repository即由具有某个功能的docker镜像的所有迭代版本构成的镜像组。registry是repository的集合，repository是镜像的集合.

3. manifest

	manifest（描述文件）主要存在于registry中作为docker镜像的元数据文件，在pull,push和load,save中作为镜像结构和基础信息的描述文件。在镜像被pull或者load到docker宿主机时，manifest被转化为本地的镜像配置文件config.

4. image

	docker内部的image概念是用来储存一组镜像相关的元数据信息，主要包括镜像的架构(如amd64)、镜像默认配置信息、构建镜像的容器配置信息、包含所有镜像层信息的rootfs。docker利用rootfs中的diff_id计算出内容寻址的索引(channID)来获取layer相关信息，进而获取每一个镜像层的文件内容

5. layer 

































